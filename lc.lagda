\documentclass[a4paper]{article}
\usepackage[margin=3cm]{geometry}
\usepackage[parfill]{parskip}

\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{amssymb} \usepackage{stmaryrd} \usepackage{csquotes}
\usepackage{unicode-math}
\usepackage{newunicodechar}

\usepackage[colorlinks = true,
            linkcolor = black,
            urlcolor  = blue,
            citecolor = black
            anchorcolor = black]{hyperref}
\usepackage[links]{agda}

%\setmathfont{XITS Math}

\newunicodechar{Œ±}{\ensuremath{\mathnormal\alpha}}
\newunicodechar{Œ≤}{\ensuremath{\mathnormal\beta}}
\newunicodechar{Œ∑}{\ensuremath{\mathnormal\eta}}
\newunicodechar{Œª}{\ensuremath{\mathnormal\lambda}}
\newunicodechar{œÄ}{\ensuremath{\mathnormal\pi}}
\newunicodechar{œï}{\ensuremath{\mathnormal\upphi}}
\newunicodechar{‚Üê}{\ensuremath{\mathnormal\from}}
\newunicodechar{‚Üí}{\ensuremath{\mathnormal\to}}
\newunicodechar{‚àÄ}{\ensuremath{\mathnormal\forall}}
\newunicodechar{‚àé}{\ensuremath{\mathnormal\blacksquare}}
\newunicodechar{‚ü®}{\ensuremath{\mathnormal\langle}}
\newunicodechar{‚ü©}{\ensuremath{\mathnormal\rangle}}
\newunicodechar{‚àò}{\ensuremath{\mathnormal\circ}}
\newunicodechar{‚â°}{\ensuremath{\mathnormal\equiv}}
\newunicodechar{‚Ñï}{\ensuremath{\mathnormal{\mathbb{N}}}}
\newunicodechar{‚Ü¶}{\ensuremath{\mathnormal\mapsto}}
\newunicodechar{‚Çõ}{\ensuremath{\mathnormal{_s}}}
\newunicodechar{‚ÇÄ}{\ensuremath{\mathnormal{_0}}}
\newunicodechar{‚ÇÅ}{\ensuremath{\mathnormal{_1}}}
\newunicodechar{‚ÇÇ}{\ensuremath{\mathnormal{_2}}}
\newunicodechar{‚ÇÉ}{\ensuremath{\mathnormal{_3}}}
\newunicodechar{‚ÇÑ}{\ensuremath{\mathnormal{_4}}}
\newunicodechar{‚ÇÖ}{\ensuremath{\mathnormal{_5}}}
\newunicodechar{‚ÇÜ}{\ensuremath{\mathnormal{_6}}}
\newunicodechar{‚Çá}{\ensuremath{\mathnormal{_7}}}
\newunicodechar{‚Çà}{\ensuremath{\mathnormal{_8}}}
\newunicodechar{‚Çâ}{\ensuremath{\mathnormal{_9}}}
\newunicodechar{ùì§}{\ensuremath{\mathnormal{\mathscr{U}}}}
\newunicodechar{‚Ñì}{\ensuremath{\mathnormal\ell}}
\newunicodechar{‚áÄ}{\ensuremath{\mathnormal\rightharpoonup}}
\newunicodechar{‚Çó}{\ensuremath{\mathnormal{_l}}}
\newunicodechar{·µ£}{\ensuremath{\mathnormal{_r}}}
\newunicodechar{‚äî}{\ensuremath{\mathnormal\sqcup}}
\newunicodechar{‚Ä≤}{\ensuremath{\mathnormal\prime}}
\newunicodechar{‚àà}{\ensuremath{\mathnormal\in}}
\newunicodechar{‚áí}{\ensuremath{\mathnormal\Rightarrow}}
\newunicodechar{‚¶Ç}{\ensuremath{\mathnormal{:}}}
\newunicodechar{‚Çç}{\ensuremath{\mathnormal{(}}}
\newunicodechar{‚Çé}{\ensuremath{\mathnormal{)}}}
\newunicodechar{‚â£}{\ensuremath{\mathnormal\Xi}}
\newunicodechar{∆õ}{\ensuremath{\mathnormal\lambda}}
\newunicodechar{‚âü}{\ensuremath{\mathnormal=?}}
\newunicodechar{‚àã}{\ensuremath{\mathnormal\ni}}
\newunicodechar{‚à∑}{\ensuremath{\mathnormal::}}
\newunicodechar{‚àß}{\ensuremath{\mathnormal\land}}
\newunicodechar{‚à®}{\ensuremath{\mathnormal\lor}}
\newunicodechar{·µá}{\ensuremath{\mathnormal{^b}}}

\title{Œª-Calculus in Agda}
\author{Joris Klaasse Bos}

\begin{document}

\maketitle

\section*{Preface}

This document is a literate Agda program that implements and explains the Œª-calculus. Of course, I recognise the tremendous irony that herein lies, seeing as we explain Œª-calculus through what is essentially not much more than an implementation of dependently typed Œª-calculus; it is unlikely that someone who knows Agda should not know Œª-calculus already‚Äîalthough they need not be familiar with Church encodings per se. This document should be seen as (very overkill) Theory of Functional Programming lecture notes by someone who is already well versed in the subject.

\tableofcontents

\section*{Prelude}

\begin{code}
module lc where
  open import Agda.Builtin.Equality
  open import Agda.Primitive using (Level; lsuc; lzero; _‚äî_) renaming (Set to ùì§)
  import Relation.Binary.PropositionalEquality as Eq
  open import Relation.Nullary using (¬¨_)
  open import Relation.Nullary.Negation using (¬¨?)
  open Eq using (_‚â°_; refl; cong; cong‚ÇÇ; cong-app; sym; trans)
  open Eq.‚â°-Reasoning using (begin_; _‚â°‚ü®‚ü©_; step-‚â°; _‚àé)
  open import Function.Base using (_‚àò_; _‚àò‚ÇÇ_; id; _‚àã_; flip)
  open import Agda.Builtin.String renaming (primStringEquality to _=‚Çõ_)
  open import Data.String using (String; _‚âü_)
  open import Data.List using (List; []; _‚à∑_; _++_; filter)
  open import Data.Bool.Base using (not; if_then_else_; Bool; true; false; _‚àß_; _‚à®_)
  open import Data.Maybe using (Maybe; just; nothing; map)

  variable
    ‚Ñì ‚Ñì‚ÇÅ ‚Ñì‚ÇÇ ‚Ñì‚ÇÉ ‚Ñì‚ÇÑ ‚Ñì‚ÇÖ ‚Ñì‚ÇÜ ‚Ñì‚Çá ‚Ñì‚Çà ‚Ñì‚Çâ : Level
    A B C D : ùì§ ‚Ñì

  -- Finds the first element satisfying the boolean predicate
  find·µá : (A ‚Üí Bool) ‚Üí List A ‚Üí Maybe A
  find·µá p []       = nothing
  find·µá p (x ‚à∑ xs) = if p x then just x else find·µá p xs

  -- Check if a list of strings contains a certain string
  contains : List String ‚Üí String ‚Üí Bool
  contains l x with find·µá (_=‚Çõ x) l
  contains l x | nothing = false
  contains l x | just _ = true

  liftM2 : (A ‚Üí B ‚Üí C) ‚Üí Maybe A ‚Üí Maybe B ‚Üí Maybe C
  liftM2 f (just x) = map (f x)
  liftM2 f nothing _ = nothing
\end{code}

\pagebreak

\section{Œª-Calculus}

\subsection{Œª-Terms}

The Œª-calculus is an incredibly simple Turing-complete language, i.e.\ it can express any computation a Turing machine can. It has only three introduction rules:

\begin{code}
  data Œª-Term : ùì§ where
    `    : String ‚Üí Œª-Term
    _‚Äø_  : Œª-Term ‚Üí Œª-Term ‚Üí Œª-Term
    _‚Ü¶_  : String ‚Üí Œª-Term ‚Üí Œª-Term
\end{code}

These three types of terms are known as \textit{variables}, \textit{applications}, and \textit{abstractions} respectively. An example of a Œª-term could be

\begin{code}
  _ = Œª-Term ‚àã ((("a" ‚Ü¶ ("b" ‚Ü¶ ` "a")) ‚Äø ` "x") ‚Äø ` "y")
\end{code}

There are a lot of parentheses there. To make it a little easier to read, we will add some precedence rules to Agda. Since interpreting \verb#("a" ‚Ü¶ "b" ‚Ü¶ ` "a")# as \verb#(("a" ‚Ü¶ "b") ‚Ü¶ ` "a")# results in a malformed expression, we will make \verb#_‚Ü¶_# right-associative. We will make application left-associative so we can read chains of applications from left to right without needing parentheses.

\begin{code}
  infixl 20 _‚Äø_
  infixr 15 _‚Ü¶_
  infix 20 `
\end{code}

We can now rewrite the previous expression as follows

\begin{code}
  _ = Œª-Term ‚àã ("a" ‚Ü¶ "b" ‚Ü¶ ` "a") ‚Äø ` "x" ‚Äø ` "y"
\end{code}

\subsection{Bound and Free Variables}

We distinguish two types of variables: \textit{bound} and \textit{free} or \textit{unbound}. When we have an abstraction, all occurrences of variables in the body of an abstraction formed from the same string as the first element of said abstraction are called bound. When a variable is not bound by any abstraction, it is called free.

We can write the following function, which returns the names of all the free variables in a Œª-term:

\begin{code}
  freeVars : Œª-Term ‚Üí List String
  freeVars (` x) = x ‚à∑ []
  freeVars (x ‚Äø y) = freeVars x ++ freeVars y
  freeVars (x ‚Ü¶ y) = filter (¬¨? ‚àò (_‚âü x)) (freeVars y)
\end{code}
For example:

\begin{code}
  _ = freeVars (("a" ‚Ü¶ "b" ‚Ü¶ ` "a") ‚Äø ` "x" ‚Äø ` "y") ‚â° "x" ‚à∑ "y" ‚à∑ [] ‚àã refl
  _ = freeVars ("a" ‚Ü¶ ` "b" ‚Äø ` "a") ‚â° "b" ‚à∑ [] ‚àã refl
\end{code}

We can also write a function to find all the names of the bound variables.

\begin{code}
  boundVars : Œª-Term ‚Üí List String
  boundVars (` x) = []
  boundVars (x ‚Äø y) = (boundVars x) ++ (boundVars y)
  boundVars (x ‚Ü¶ y) = x ‚à∑ (boundVars y)

  _ = boundVars (("a" ‚Ü¶ "b" ‚Ü¶ ` "a") ‚Äø ` "x" ‚Äø ` "y") ‚â° "a" ‚à∑ "b" ‚à∑ [] ‚àã refl
  _ = boundVars ("a" ‚Ü¶ ` "b" ‚Äø ` "a") ‚â° "a" ‚à∑ [] ‚àã refl
\end{code}

Of course, there may be overlap between the results of \verb#freeVars# and \verb#boundVars#, because we are only looking for the names of variables that are bound or free; a name may be used for a bound variable in one subexpression, but free in another.

\subsection{Substitution}

When we give computational meaning to Œª-terms, we will make use of substitution, so we will invent a function for performing substitutions. Do keep in mind that we are not adding something new to the definition of the Œª-calculus, but just defining a function in the meta-language Agda to be able to define the computation rules we will see hereafter. We disallow substitutions that change the binding of a variable.
\begin{code}
  _[_:=_] : Œª-Term ‚Üí String ‚Üí Œª-Term ‚Üí Maybe Œª-Term
  ` v [ x := y ] = if v =‚Çõ x then just y else just (` v)
  e‚ÇÅ ‚Äø e‚ÇÇ [ x := y ] = liftM2 _‚Äø_ (e‚ÇÅ [ x := y ]) (e‚ÇÇ [ x := y ])
  (v ‚Ü¶ e) [ x := y ] =
    if x =‚Çõ v
      then just (v ‚Ü¶ e)  -- Don't do anything when we have an inner rebind
      else if contains (freeVars y) v
        then nothing
        else map (v ‚Ü¶_) (e [ x := y ])
\end{code}
Examples:
\begin{code}
  _ =  ("a" ‚Ü¶ "b" ‚Ü¶ ` "a") ‚Äø ` "x" ‚Äø ` "a" [ "a" := ` "c" ]
       ‚â° just (("a" ‚Ü¶ "b" ‚Ü¶ ` "a") ‚Äø ` "x" ‚Äø ` "c") ‚àã refl
  _ =  ("a" ‚Ü¶ "b" ‚Ü¶ ` "a" ‚Äø ` "c") ‚Äø ` "c" ‚Äø ` "a" [ "c" := ` "x" ]
       ‚â° just (("a" ‚Ü¶ "b" ‚Ü¶ ` "a" ‚Äø ` "x") ‚Äø ` "x" ‚Äø ` "a")  ‚àã refl
  _ =  ("a" ‚Ü¶ "b" ‚Ü¶ ` "c") ‚Äø ` "c" ‚Äø ` "a" [ "c" := ` "a" ]
       ‚â° nothing ‚àã refl
\end{code}

\subsection{Œ±-Equivalence}

\textit{Œ±-Equivalence}, also known as \textit{Œ±-conversion} and \textit{Œ±-renaming}, states that the name of a variable in a Œª-abstraction does not matter; the name is only used to identify which variable is bound to which Œª-abstraction. It states we should be able to rename the variable of a Œª-abstraction and be left with an expression that is somehow \enquote{the same}. Of course, the restrictions imposed on substitution still apply. We will also add some recursive definitions so it applies Œ±-equivalence to the first Œª-abstraction it encounters for ease of use.

\begin{code}
  Œ±-equiv : String ‚Üí Œª-Term ‚Üí Maybe Œª-Term
  Œ±-equiv x (v ‚Ü¶ y) = map (x ‚Ü¶_) (y [ v := ` x ])  -- Main definition
  Œ±-equiv x (` x‚ÇÅ) = nothing
  Œ±-equiv x (e‚ÇÅ ‚Äø e‚ÇÇ) with Œ±-equiv x e‚ÇÅ
  Œ±-equiv x (e‚ÇÅ ‚Äø e‚ÇÇ) | nothing = map (e‚ÇÅ ‚Äø_) (Œ±-equiv x e‚ÇÇ)
  Œ±-equiv x (e‚ÇÅ ‚Äø e‚ÇÇ) | just e‚ÇÅ' = just (e‚ÇÅ' ‚Äø e‚ÇÇ)
\end{code}
Example:
\begin{code}
  _ =  Œ±-equiv "z" ("a" ‚Ü¶ "b" ‚Ü¶ ("c" ‚Ü¶ ` "a" ‚Äø ` "c") ‚Äø ` "b" ‚Äø ` "a")
       ‚â° just ("z" ‚Ü¶ "b" ‚Ü¶ ("c" ‚Ü¶ ` "z" ‚Äø ` "c") ‚Äø ` "b" ‚Äø ` "z") ‚àã refl
  _ =  Œ±-equiv "b" ("a" ‚Ü¶ "b" ‚Ü¶ ("c" ‚Ü¶ ` "a" ‚Äø ` "c") ‚Äø ` "b" ‚Äø ` "a")
       ‚â° nothing ‚àã refl -- Name clash
\end{code}

\subsection{Œ≤-Reduction}

Now we get to the crux of the matter: \textit{Œ≤-reduction}. Œ≤-Reduction explains how we compute Œª-terms, namely, if we apply a Œª-abstraction to a Œª-term, we can obtain a new Œª-term by substituting the term we are applying to for the bound variable in the body of the abstraction. We will also add recursive calls for Œ≤-reduction when talking about expressions other than functions, so we will just reduce the first application we encounter.

\begin{code}
  Œ≤-reduc : Œª-Term ‚Üí Maybe Œª-Term
  Œ≤-reduc ((v ‚Ü¶ e‚ÇÅ) ‚Äø e‚ÇÇ) = e‚ÇÅ [ v := e‚ÇÇ ] -- Main definition
  Œ≤-reduc (` v) = nothing
  Œ≤-reduc (v ‚Ü¶ e) = map (v ‚Ü¶_) (Œ≤-reduc e)
  Œ≤-reduc (e‚ÇÅ ‚Äø e‚ÇÇ) with Œ≤-reduc e‚ÇÅ
  Œ≤-reduc (e‚ÇÅ ‚Äø e‚ÇÇ) | nothing = map (e‚ÇÅ ‚Äø_) (Œ≤-reduc e‚ÇÇ)
  Œ≤-reduc (e‚ÇÅ ‚Äø e‚ÇÇ) | just e‚ÇÅ' = just (e‚ÇÅ' ‚Äø e‚ÇÇ)
\end{code}
Examples:
\begin{code}
  _ =  Œ≤-reduc (("a" ‚Ü¶ "b" ‚Ü¶ ` "b") ‚Äø ` "x")
       ‚â° just ("b" ‚Ü¶ ` "b") ‚àã refl
  _ =  Œ≤-reduc (("a" ‚Ü¶ "b" ‚Ü¶ ` "a") ‚Äø ` "x")
       ‚â° just ("b" ‚Ü¶ ` "x") ‚àã refl
  _ =  Œ≤-reduc (("a" ‚Ü¶ "b" ‚Ü¶ ` "a") ‚Äø ` "b")
       ‚â° nothing ‚àã refl -- Name clash
\end{code}

\subsection{Œ∑-Reduction}

\subsection{Equational Reasoning}

\begin{code}
  data _‚ÜíMŒª_ (e‚ÇÅ : Œª-Term) : Maybe Œª-Term ‚Üí ùì§ where
    Œ±        : {v : String} ‚Üí e‚ÇÅ ‚ÜíMŒª Œ±-equiv v e‚ÇÅ
    Œ≤        : e‚ÇÅ ‚ÜíMŒª Œ≤-reduc e‚ÇÅ
    Œª-refl   : e‚ÇÅ ‚ÜíMŒª just e‚ÇÅ
    Œª-trans  : {e‚ÇÇ e‚ÇÉ : Œª-Term}
             ‚Üí e‚ÇÅ ‚ÜíMŒª just e‚ÇÇ
             ‚Üí e‚ÇÇ ‚ÜíMŒª just e‚ÇÉ
             ‚Üí e‚ÇÅ ‚ÜíMŒª just e‚ÇÉ

  _‚ÜíŒª_ : Œª-Term ‚Üí Œª-Term ‚Üí ùì§
  e‚ÇÅ ‚ÜíŒª e‚ÇÇ = e‚ÇÅ ‚ÜíMŒª just e‚ÇÇ

  step‚ÜíŒª : ‚àÄ (x {y z} : Œª-Term) ‚Üí y ‚ÜíŒª z ‚Üí x ‚ÜíŒª y ‚Üí x ‚ÜíŒª z
  step‚ÜíŒª _ = flip Œª-trans

  syntax step‚ÜíŒª x y‚ÜíŒªz x‚ÜíŒªy = x ‚Üí‚ü® x‚ÜíŒªy ‚ü© y‚ÜíŒªz

  _‚àéŒª : (e : Œª-Term) ‚Üí e ‚ÜíŒª e
  e ‚àéŒª = Œª-refl

  infixr 5 step‚ÜíŒª
  infix 6 _‚àéŒª
\end{code}
Example:
\begin{code}
  _ =          ("a" ‚Ü¶ "b" ‚Ü¶ ` "b") ‚Äø ` "x" ‚Äø ` "y"
       ‚Üí‚ü® Œ≤ ‚ü©  ("b" ‚Ü¶ ` "b") ‚Äø ` "y"
       ‚Üí‚ü® Œ≤ ‚ü©  ` "y" ‚àéŒª
\end{code}

\section{Syntax}

\subsection{Parser Combinators}

\subsection{Core Syntax}

\subsection{Extended Syntax}

\section{Combinatory Logic}

\section{Church Encodings}

\end{document}
