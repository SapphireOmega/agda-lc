\documentclass[a4paper]{article}
\usepackage[margin=2.5cm]{geometry}
\usepackage[parfill]{parskip}

\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{amssymb} \usepackage{stmaryrd} \usepackage{csquotes}
\usepackage{unicode-math}
\usepackage{newunicodechar}

\usepackage[colorlinks = true,
            linkcolor = black,
            urlcolor  = blue,
            citecolor = black
            anchorcolor = black]{hyperref}
\usepackage[links]{agda}

%\setmathfont{XITS Math}

\newunicodechar{Œ±}{\ensuremath{\mathnormal\alpha}}
\newunicodechar{Œ≤}{\ensuremath{\mathnormal\beta}}
\newunicodechar{Œ∑}{\ensuremath{\mathnormal\eta}}
\newunicodechar{Œª}{\ensuremath{\mathnormal\lambda}}
\newunicodechar{Œõ}{\ensuremath{\mathnormal\Lambda}}
\newunicodechar{œÄ}{\ensuremath{\mathnormal\pi}}
\newunicodechar{œï}{\ensuremath{\mathnormal\upphi}}
\newunicodechar{‚Üê}{\ensuremath{\mathnormal\from}}
\newunicodechar{‚Üí}{\ensuremath{\mathnormal\to}}
\newunicodechar{‚àÄ}{\ensuremath{\mathnormal\forall}}
\newunicodechar{‚àé}{\ensuremath{\mathnormal\blacksquare}}
\newunicodechar{‚ü®}{\ensuremath{\mathnormal\langle}}
\newunicodechar{‚ü©}{\ensuremath{\mathnormal\rangle}}
\newunicodechar{‚àò}{\ensuremath{\mathnormal\circ}}
\newunicodechar{‚â°}{\ensuremath{\mathnormal\equiv}}
\newunicodechar{‚Ñï}{\ensuremath{\mathnormal{\mathbb{N}}}}
\newunicodechar{‚Ü¶}{\ensuremath{\mathnormal\mapsto}}
\newunicodechar{‚Çõ}{\ensuremath{\mathnormal{_s}}}
\newunicodechar{‚ÇÄ}{\ensuremath{\mathnormal{_0}}}
\newunicodechar{‚ÇÅ}{\ensuremath{\mathnormal{_1}}}
\newunicodechar{‚ÇÇ}{\ensuremath{\mathnormal{_2}}}
\newunicodechar{‚ÇÉ}{\ensuremath{\mathnormal{_3}}}
\newunicodechar{‚ÇÑ}{\ensuremath{\mathnormal{_4}}}
\newunicodechar{‚ÇÖ}{\ensuremath{\mathnormal{_5}}}
\newunicodechar{‚ÇÜ}{\ensuremath{\mathnormal{_6}}}
\newunicodechar{‚Çá}{\ensuremath{\mathnormal{_7}}}
\newunicodechar{‚Çà}{\ensuremath{\mathnormal{_8}}}
\newunicodechar{‚Çâ}{\ensuremath{\mathnormal{_9}}}
\newunicodechar{ùì§}{\ensuremath{\mathnormal{\mathscr{U}}}}
\newunicodechar{‚Ñì}{\ensuremath{\mathnormal\ell}}
\newunicodechar{‚áÄ}{\ensuremath{\mathnormal\rightharpoonup}}
\newunicodechar{‚Çó}{\ensuremath{\mathnormal{_l}}}
\newunicodechar{·µ£}{\ensuremath{\mathnormal{_r}}}
\newunicodechar{‚äî}{\ensuremath{\mathnormal\sqcup}}
\newunicodechar{‚Ä≤}{\ensuremath{\mathnormal\prime}}
\newunicodechar{‚àà}{\ensuremath{\mathnormal\in}}
\newunicodechar{‚áí}{\ensuremath{\mathnormal\Rightarrow}}
\newunicodechar{‚¶Ç}{\ensuremath{\mathnormal{:}}}
\newunicodechar{‚Çç}{\ensuremath{\mathnormal{(}}}
\newunicodechar{‚Çé}{\ensuremath{\mathnormal{)}}}
\newunicodechar{‚â£}{\ensuremath{\mathnormal\Xi}}
\newunicodechar{∆õ}{\ensuremath{\mathnormal\lambda}}
\newunicodechar{‚âü}{\ensuremath{\mathnormal=?}}
\newunicodechar{‚àã}{\ensuremath{\mathnormal\ni}}
\newunicodechar{‚à∑}{\ensuremath{\mathnormal::}}
\newunicodechar{‚àß}{\ensuremath{\mathnormal\land}}
\newunicodechar{‚à®}{\ensuremath{\mathnormal\lor}}
\newunicodechar{·µá}{\ensuremath{\mathnormal{^b}}}

\title{Œª-Calculus in Agda}
\author{Joris Klaasse Bos}

\begin{document}

\maketitle

\section*{Preface}

This document is a literate Agda program that implements and explains the Œª-calculus. I recognise the tremendous irony that herein lies, seeing as we explain Œª-calculus through what is essentially not much more than an implementation of dependently typed Œª-calculus; it is unlikely that someone who knows Agda should not know Œª-calculus already‚Äîalthough they need not be familiar with Church encodings per se. This document should be seen as (very overkill) Theory of Functional Programming lecture notes by someone who is already well versed in the subject.

\tableofcontents

\section*{Prelude}

\begin{code}
module lc where
  open import Agda.Builtin.Equality
  open import Agda.Primitive using (Level; lsuc; lzero; _‚äî_) renaming (Set to ùì§)
  import Relation.Binary.PropositionalEquality as Eq
  open import Relation.Nullary using (¬¨_)
  open import Relation.Nullary.Negation using (¬¨?)
  open Eq using (_‚â°_; refl; cong; cong‚ÇÇ; cong-app; sym; trans)
  open Eq.‚â°-Reasoning using (begin_; _‚â°‚ü®‚ü©_; step-‚â°; _‚àé)
  open import Function.Base using (_‚àò_; _‚àò‚ÇÇ_; id; _‚àã_; flip; _$_)
  open import Agda.Builtin.String renaming (primStringEquality to _=‚Çõ_)
  open import Data.String using (String; _‚âü_)
  open import Data.List using (List; []; _‚à∑_; _++_; filter)
  open import Data.Bool.Base using (not; if_then_else_; Bool; true; false; _‚àß_; _‚à®_)
  open import Data.Maybe using (Maybe; just; nothing; map)

  variable
    ‚Ñì ‚Ñì‚ÇÅ ‚Ñì‚ÇÇ ‚Ñì‚ÇÉ ‚Ñì‚ÇÑ ‚Ñì‚ÇÖ ‚Ñì‚ÇÜ ‚Ñì‚Çá ‚Ñì‚Çà ‚Ñì‚Çâ : Level
    A B C D : ùì§ ‚Ñì

  -- Finds the first element satisfying the boolean predicate
  find·µá : (A ‚Üí Bool) ‚Üí List A ‚Üí Maybe A
  find·µá p []       = nothing
  find·µá p (x ‚à∑ xs) = if p x then just x else find·µá p xs

  -- Check if a list of strings contains a certain string
  contains : List String ‚Üí String ‚Üí Bool
  contains l x with find·µá (_=‚Çõ x) l
  contains l x | nothing = false
  contains l x | just _ = true

  liftM2 : (A ‚Üí B ‚Üí C) ‚Üí Maybe A ‚Üí Maybe B ‚Üí Maybe C
  liftM2 f (just x) = map (f x)
  liftM2 f nothing _ = nothing
\end{code}

\pagebreak

\section{Œª-Calculus}

The two most important subsections of this section are subsections \ref{terms} and \ref{reduc}. These two subsections define the terms of the Œª-calculus and the one computation rule respectively. However, since we use named variables in our definition of Œª-terms, and since the name of a variable should not matter for the meaning of a Œª-term, we need to add some extra scaffolding to deal with these variable names and possible clashes, and spend some more time on the interpretation of a Œª-term. There are other representations of Œª-terms possible which do not suffer from these same setbacks, such as \textit{de Bruijn representation}, but these are harder for humans to read. If you want to get a quick overview of Œª-calculus, it would suffise to just read the main two subsections, but you will be missing some context which would be necessary to have a solid grasp of Œª-calculus.

Strictly speaking we will not be defining the syntax of the Œª-calculus in this section. Rather, we represent Œª-terms as Agda data types. Agda syntax is quite flexible, so we can make it relatively legible, but really we will just be programming in the abstract syntax tree (AST) directly (for now). We will actually define the syntax in the next section (\ref{syntax}).

\subsection{Œª-Terms}\label{terms}

The Œª-calculus is an incredibly simple Turing-complete language, i.e.\ it can express any computation a Turing machine can. It has only three introduction rules:

\begin{code}
  data Œõ : ùì§ where
    `    : String ‚Üí Œõ
    _‚Äø_  : Œõ ‚Üí Œõ ‚Üí Œõ
    _‚Ü¶_  : String ‚Üí Œõ ‚Üí Œõ
\end{code}

These three types of terms are known as \textit{variables}, \textit{applications}, and \textit{(Œª-)abstractions} respectively. An example of a Œª-term could be

\begin{code}
  _ = Œõ ‚àã ((("a" ‚Ü¶ ("b" ‚Ü¶ ` "a")) ‚Äø ` "x") ‚Äø ` "y")
\end{code}

There are a lot of parentheses there. To make it a little easier to read, we will add some precedence rules to Agda. Since interpreting \verb#("a" ‚Ü¶ "b" ‚Ü¶ ` "a")# as \verb#(("a" ‚Ü¶ "b") ‚Ü¶ ` "a")# results in a malformed expression, we will make \verb#_‚Ü¶_# right-associative. We will make application left-associative so we can read chains of applications from left to right without needing parentheses.

\begin{code}
  infixl 20 _‚Äø_
  infixr 15 _‚Ü¶_
  infix 20 `
\end{code}

We can now rewrite the previous expression as follows

\begin{code}
  _ = Œõ ‚àã ("a" ‚Ü¶ "b" ‚Ü¶ ` "a") ‚Äø ` "x" ‚Äø ` "y"
\end{code}

More examples (from the slides):
\begin{code}
  _ = Œõ ‚àã ` "v"
  _ = Œõ ‚àã ` "v" ‚Äø ` "v"
  _ = Œõ ‚àã ` "v" ‚Äø ` "v'"
  _ = Œõ ‚àã "v" ‚Ü¶ ` "v" ‚Äø ` "v'"
  _ = Œõ ‚àã ` "v" ‚Äø ("v" ‚Ü¶ ` "v" ‚Äø ` "v'")
\end{code}

\subsection{Bound and Free Variables}

We distinguish two types of variables: \textit{bound} and \textit{free} or \textit{unbound}. When we have an abstraction, all occurrences of variables in the body of an abstraction formed from the same string as the first element of said abstraction are called bound. When a variable is not bound by any abstraction, it is called free.

We can write the following function, which returns the names of all the free variables in a Œª-term:

\begin{code}
  freeVars : Œõ ‚Üí List String
  freeVars (` x) = x ‚à∑ []
  freeVars (x ‚Äø y) = freeVars x ++ freeVars y
  freeVars (x ‚Ü¶ y) = filter (¬¨? ‚àò (_‚âü x)) (freeVars y)
\end{code}
For example:

\begin{code}
  _ = freeVars (("a" ‚Ü¶ "b" ‚Ü¶ ` "a") ‚Äø ` "x" ‚Äø ` "y") ‚â° "x" ‚à∑ "y" ‚à∑ [] ‚àã refl
  _ = freeVars ("a" ‚Ü¶ ` "b" ‚Äø ` "a") ‚â° "b" ‚à∑ [] ‚àã refl
  -- From the slides:
  _ = freeVars (` "x" ‚Äø (("x" ‚Ü¶ ` "x" ‚Äø ` "y")) ‚Äø ` "x") ‚â° "x" ‚à∑ "y" ‚à∑ "x" ‚à∑ [] ‚àã refl
\end{code}

We can also write a function to find all the names of the bound variables.

\begin{code}
  boundVars : Œõ ‚Üí List String
  boundVars (` x) = []
  boundVars (x ‚Äø y) = (boundVars x) ++ (boundVars y)
  boundVars (x ‚Ü¶ y) = x ‚à∑ (boundVars y)

  _ = boundVars (("a" ‚Ü¶ "b" ‚Ü¶ ` "a") ‚Äø ` "x" ‚Äø ` "y") ‚â° "a" ‚à∑ "b" ‚à∑ [] ‚àã refl
  _ = boundVars ("a" ‚Ü¶ ` "b" ‚Äø ` "a") ‚â° "a" ‚à∑ [] ‚àã refl
  -- From the slides:
  _ = boundVars (` "x" ‚Äø (("x" ‚Ü¶ ` "x" ‚Äø ` "y")) ‚Äø ` "x") ‚â° "x" ‚à∑ [] ‚àã refl
\end{code}

Of course, there may be overlap between the results of \verb#freeVars# and \verb#boundVars#, because we are only looking for the names of variables that are bound or free; a name may be used for a bound variable in one subexpression, but a free one in another.

\subsection{Substitution}

When we give computational meaning to Œª-terms, we will make use of substitution, so we will invent a function for performing substitutions. Do keep in mind that we are not adding something new to the definition of the Œª-calculus, but just defining a function in the meta-language Agda to be able to define the computation rules we will see hereafter. We disallow substitutions that change the binding of a variable to avoid name clashes later on. When a variable is bound multiple times, by convention we say it is bound by the inner most binding abstraction. If we are substituting a variable, but it gets rebound in a subexpression, we do not substitute it in that expression.
\begin{code}
  _[_:=_] : Œõ ‚Üí String ‚Üí Œõ ‚Üí Maybe Œõ
  ` v      [ x := y ] = if v =‚Çõ x then just y else just (` v)
  e‚ÇÅ ‚Äø e‚ÇÇ  [ x := y ] = liftM2 _‚Äø_ (e‚ÇÅ [ x := y ]) (e‚ÇÇ [ x := y ])
  (v ‚Ü¶ e)  [ x := y ] =
    if x =‚Çõ v
      then just (v ‚Ü¶ e)  -- Don't do anything when we have an inner rebind
      else if contains (freeVars y) v
        then nothing     -- Would change the binding of a variable
        else map (v ‚Ü¶_) (e [ x := y ])
\end{code}
Examples:
\begin{code}
  _ =  ("a" ‚Ü¶ "b" ‚Ü¶ ` "a") ‚Äø ` "x" ‚Äø ` "a" [ "a" := ` "c" ]
       ‚â° just (("a" ‚Ü¶ "b" ‚Ü¶ ` "a") ‚Äø ` "x" ‚Äø ` "c") ‚àã refl
  _ =  ("a" ‚Ü¶ "b" ‚Ü¶ ` "a" ‚Äø ` "c") ‚Äø ` "c" ‚Äø ` "a" [ "c" := ` "x" ]
       ‚â° just (("a" ‚Ü¶ "b" ‚Ü¶ ` "a" ‚Äø ` "x") ‚Äø ` "x" ‚Äø ` "a")  ‚àã refl
  _ =  ("a" ‚Ü¶ "b" ‚Ü¶ ` "c") ‚Äø ` "c" ‚Äø ` "a" [ "c" := ` "a" ]
       ‚â° nothing ‚àã refl
  -- From the slides:
  _ =  (  ‚àÄ {n : Œõ} ‚Üí
            ` "x" ‚Äø (("x" ‚Ü¶ ` "x" ‚Äø ` "y") ‚Äø ` "x") ["x" := n ]
            ‚â° just (n ‚Äø (("x" ‚Ü¶ ` "x" ‚Äø ` "y") ‚Äø n))
       )  ‚àã refl
\end{code}

\subsection{Œ±-Equivalence}

\textit{Œ±-Equivalence}, also known as \textit{Œ±-conversion} and \textit{Œ±-renaming}, states that the name of a variable in a Œª-abstraction does not matter; the name is only used to identify which variable is bound to which Œª-abstraction. It states we should be able to rename the variable of a Œª-abstraction and be left with an expression that is somehow \enquote{the same}. Of course, the restrictions imposed on substitution still apply, and these restrictions avoid name clashes which would actually changing the meaning of a Œª-term. We will also add some recursive definitions so it applies Œ±-equivalence to the first Œª-abstraction it encounters for ease of use.

\begin{code}
  Œ±-equiv : String ‚Üí Œõ ‚Üí Maybe Œõ
  Œ±-equiv x (v ‚Ü¶ y) = map (x ‚Ü¶_) (y [ v := ` x ])  -- Main definition
  Œ±-equiv x (` x‚ÇÅ) = nothing
  Œ±-equiv x (e‚ÇÅ ‚Äø e‚ÇÇ) with Œ±-equiv x e‚ÇÅ
  Œ±-equiv x (e‚ÇÅ ‚Äø e‚ÇÇ) | nothing = map (e‚ÇÅ ‚Äø_) (Œ±-equiv x e‚ÇÇ)
  Œ±-equiv x (e‚ÇÅ ‚Äø e‚ÇÇ) | just e‚ÇÅ' = just (e‚ÇÅ' ‚Äø e‚ÇÇ)
\end{code}
Examples:
\begin{code}
  _ =  Œ±-equiv "z" ("a" ‚Ü¶ "b" ‚Ü¶ ("c" ‚Ü¶ ` "a" ‚Äø ` "c") ‚Äø ` "b" ‚Äø ` "a")
       ‚â° just ("z" ‚Ü¶ "b" ‚Ü¶ ("c" ‚Ü¶ ` "z" ‚Äø ` "c") ‚Äø ` "b" ‚Äø ` "z") ‚àã refl
  _ =  Œ±-equiv "b" ("a" ‚Ü¶ "b" ‚Ü¶ ("c" ‚Ü¶ ` "a" ‚Äø ` "c") ‚Äø ` "b" ‚Äø ` "a")
       ‚â° nothing ‚àã refl -- Name clash
\end{code}

\subsection{Œ≤-Reduction}\label{reduc}

Now we get to the crux of the matter: \textit{Œ≤-reduction}. Œ≤-Reduction explains how we compute Œª-terms, namely, if we apply a Œª-abstraction to a Œª-term, we can obtain a new Œª-term by substituting the term we are applying to for the bound variable in the body of the abstraction. We will also add recursive calls for Œ≤-reduction when talking about expressions other than functions, so we will just reduce the first application we encounter.

\begin{code}
  Œ≤-reduc : Œõ ‚Üí Maybe Œõ
  Œ≤-reduc ((v ‚Ü¶ e‚ÇÅ) ‚Äø e‚ÇÇ) = e‚ÇÅ [ v := e‚ÇÇ ] -- Main definition
  Œ≤-reduc (` v) = nothing
  Œ≤-reduc (v ‚Ü¶ e) = map (v ‚Ü¶_) (Œ≤-reduc e)
  Œ≤-reduc (e‚ÇÅ ‚Äø e‚ÇÇ) with Œ≤-reduc e‚ÇÅ
  Œ≤-reduc (e‚ÇÅ ‚Äø e‚ÇÇ) | nothing = map (e‚ÇÅ ‚Äø_) (Œ≤-reduc e‚ÇÇ)
  Œ≤-reduc (e‚ÇÅ ‚Äø e‚ÇÇ) | just e‚ÇÅ' = just (e‚ÇÅ' ‚Äø e‚ÇÇ)
\end{code}
Examples:
\begin{code}
  _ =  Œ≤-reduc (("a" ‚Ü¶ "b" ‚Ü¶ ` "b") ‚Äø ` "x")
       ‚â° just ("b" ‚Ü¶ ` "b") ‚àã refl
  _ =  Œ≤-reduc (("a" ‚Ü¶ "b" ‚Ü¶ ` "a") ‚Äø ` "x")
       ‚â° just ("b" ‚Ü¶ ` "x") ‚àã refl
  _ =  Œ≤-reduc (("a" ‚Ü¶ "b" ‚Ü¶ ` "a") ‚Äø ` "b")
       ‚â° nothing ‚àã refl -- Name clash
  -- From the slides:
  _ =  Œ≤-reduc (("x" ‚Ü¶ ` "y" ‚Äø ` "x") ‚Äø (` "z" ‚Äø ` "z"))
       ‚â° just (` "y" ‚Äø (` "z" ‚Äø ` "z")) ‚àã refl
\end{code}

Now that we have given computational meaning to applications of Œª-abstractions, we will interchangeably call Œª-abstractions (Œª-)functions, since now they actually \enquote{function}.

\subsection{Equational Reasoning}

We will create a type which encodes the proposition that some Œª-term is reducible to another. These reductions can be done by Œ≤-reduction or Œ±-equivalence. Since \verb#Œ≤-reduc# and \verb#Œ±-equiv# return \verb#Maybe#'s, we will make the type have a \verb#Maybe# in its right argument.

\begin{code}
  data _‚ÜíMŒª_ : Œõ ‚Üí Maybe Œõ ‚Üí ùì§ where
\end{code}

Œ±-Equivalence and Œ≤-reduction:

\begin{code}
    Œ±        : ‚àÄ {e : Œõ} {v : String}  ‚Üí e ‚ÜíMŒª Œ±-equiv v e
    Œ≤        : ‚àÄ {e : Œõ}               ‚Üí e ‚ÜíMŒª Œ≤-reduc e
\end{code}

We will add another reduction rule called \textit{Œ∑-reduction}. This is an optional extension to the Œª-calculus which we will discuss in the next subsection, so you can ignore it for now.

\begin{code}
    Œ∑        : ‚àÄ {e : Œõ} {v : String} ‚Üí (v ‚Ü¶ e ‚Äø ` v) ‚ÜíMŒª just e
\end{code}

We will add transitivity so we can chain reductions into one larger reduction, where we keep unwrapping the \verb#Maybe# in between. This also means that we cannot form reductions using \verb#nothing#'s. We also add reflexivity, so doing nothing is also a valid reduction. This will be useful when defining equational reasoning with the type.

\begin{code}
    Œª-trans  : ‚àÄ {e‚ÇÅ e‚ÇÇ e‚ÇÉ : Œõ}  ‚Üí e‚ÇÅ ‚ÜíMŒª just e‚ÇÇ ‚Üí e‚ÇÇ ‚ÜíMŒª just e‚ÇÉ ‚Üí e‚ÇÅ ‚ÜíMŒª just e‚ÇÉ
    Œª-refl   : ‚àÄ {e‚ÇÅ : Œõ}        ‚Üí e‚ÇÅ ‚ÜíMŒª just e‚ÇÅ
\end{code}

With our definition thus far we can only apply Œ±-equivalence and Œ≤-reduction to the first (sub)expression to which they are applicable (as that is how we have defined \verb#Œ±-equiv# and \verb#Œ≤-reduc#) in \textit{lazy evaluation order}. This is not so much a problem for Œ≤-reduction as it is for Œ±-equivalence, since we might want to apply Œ±-equivalence to a subexpression to show that the whole expression is Œ±-equivalent to another‚Äîwith Œ≤-reduction we can just repeatedly apply it until we are \enquote{done}, where the order does not matter all that much (except if possible infinite computations are involved). To avoid this problem with Œ±-equivalence, we will say that applying a reduction to a subexpression is also a valid reduction.

\begin{code}
    Œª-left   : ‚àÄ {e‚ÇÅ e‚ÇÇ e‚ÇÉ : Œõ}            ‚Üí e‚ÇÅ ‚ÜíMŒª just e‚ÇÇ ‚Üí (e‚ÇÅ ‚Äø e‚ÇÉ) ‚ÜíMŒª just (e‚ÇÇ ‚Äø e‚ÇÉ)
    Œª-right  : ‚àÄ {e‚ÇÅ e‚ÇÇ e‚ÇÉ : Œõ}            ‚Üí e‚ÇÅ ‚ÜíMŒª just e‚ÇÇ ‚Üí (e‚ÇÉ ‚Äø e‚ÇÅ) ‚ÜíMŒª just (e‚ÇÉ ‚Äø e‚ÇÅ)
    Œª-body   : ‚àÄ {e‚ÇÅ e‚ÇÇ : Œõ} {v : String}  ‚Üí e‚ÇÅ ‚ÜíMŒª just e‚ÇÇ ‚Üí (v ‚Ü¶ e‚ÇÅ) ‚ÜíMŒª just (v ‚Ü¶ e‚ÇÇ)
\end{code}

This completes our definition of this type.

We will add a shorthand for \verb#e‚ÇÅ ‚ÜíMŒª just e‚ÇÇ#.

\begin{code}
  _‚ÜíŒª_ : Œõ ‚Üí Œõ ‚Üí ùì§
  e‚ÇÅ ‚ÜíŒª e‚ÇÇ = e‚ÇÅ ‚ÜíMŒª just e‚ÇÇ
\end{code}

We can now define equational reasoning analogously to equational reasoning with propositional equality in the Agda standard library.

\begin{code}
  infix   5 Œª-begin
  infixr  6 step‚ÜíŒª
  infix   7 _Œª-end

  Œª-begin : Œõ ‚Üí Œõ
  Œª-begin = id

  step‚ÜíŒª : ‚àÄ (x {y z} : Œõ) ‚Üí y ‚ÜíŒª z ‚Üí x ‚ÜíŒª y ‚Üí x ‚ÜíŒª z
  step‚ÜíŒª _ = flip Œª-trans

  syntax step‚ÜíŒª x y‚ÜíŒªz x‚ÜíŒªy = x ‚Üí‚ü® x‚ÜíŒªy ‚ü© y‚ÜíŒªz

  _Œª-end : ‚àÄ (e : Œõ) ‚Üí e ‚ÜíŒª e
  e Œª-end = Œª-refl
\end{code}

Examples:

\begin{code}
  _ =  Œª-begin  ("a" ‚Ü¶ "b" ‚Ü¶ ` "b") ‚Äø ` "x" ‚Äø ` "y"
       ‚Üí‚ü® Œ≤ ‚ü©   ("b" ‚Ü¶ ` "b") ‚Äø ` "y"
       ‚Üí‚ü® Œ≤ ‚ü©   ` "y"
       Œª-end

  _ =  Œª-begin  ("x" ‚Ü¶ "y" ‚Ü¶ "z" ‚Ü¶ ` "x" ‚Äø ` "z" ‚Äø ` "y") ‚Äø ("x" ‚Ü¶ "y" ‚Ü¶ ` "x")
       ‚Üí‚ü® Œ≤ ‚ü©   "y" ‚Ü¶ "z" ‚Ü¶  ("x" ‚Ü¶ "y" ‚Ü¶ ` "x") ‚Äø ` "z" ‚Äø ` "y"
       ‚Üí‚ü® Œ≤ ‚ü©   "y" ‚Ü¶ "z" ‚Ü¶  ("y" ‚Ü¶ ` "z") ‚Äø ` "y"
       ‚Üí‚ü® Œ≤ ‚ü©   "y" ‚Ü¶ "z" ‚Ü¶  ` "z"
       ‚Üí‚ü® Œ± {v = "x"} ‚ü©
                "x" ‚Ü¶ "z" ‚Ü¶  ` "z"
       ‚Üí‚ü® Œª-body Œ± ‚ü©
                "x" ‚Ü¶ "y" ‚Ü¶  ` "y"
       Œª-end

  _ =  Œª-begin  ("x" ‚Ü¶ "y" ‚Ü¶ "z" ‚Ü¶ ` "x" ‚Äø ` "z" ‚Äø ` "y") ‚Äø ("x" ‚Ü¶ "y" ‚Ü¶ ` "z")
       ‚Üí‚ü® Œª-left $ Œª-body $ Œª-body Œ± ‚ü©
                ("x" ‚Ü¶ "y" ‚Ü¶ "w" ‚Ü¶ ` "x" ‚Äø ` "w" ‚Äø ` "y") ‚Äø ("x" ‚Ü¶ "y" ‚Ü¶ ` "z")
       ‚Üí‚ü® Œ≤ ‚ü©   "y" ‚Ü¶ "w" ‚Ü¶ ("x" ‚Ü¶ "y" ‚Ü¶ ` "z") ‚Äø ` "w" ‚Äø ` "y"
       ‚Üí‚ü® Œ≤ ‚ü©   "y" ‚Ü¶ "w" ‚Ü¶ ("y" ‚Ü¶ ` "z") ‚Äø ` "y"
       ‚Üí‚ü® Œ≤ ‚ü©   "y" ‚Ü¶ "w" ‚Ü¶ ` "z"
       ‚Üí‚ü® Œ± {v = "x"} ‚ü©
                "x" ‚Ü¶ "w" ‚Ü¶ ` "z"
       ‚Üí‚ü® Œª-body $ Œ± ‚ü©
                "x" ‚Ü¶ "y" ‚Ü¶ ` "z"
       Œª-end
\end{code}

\subsection{Œ∑-Reduction}

In the last subsection we added a second reduction rule called \textit{Œ∑-Reduction}, which people sometimes extend the lambda calculus with. It states the following:

\verb#     Œ∑ : ‚àÄ {e : Œõ} {v : String} ‚Üí (v ‚Ü¶ e ‚Äø ` v) ‚ÜíŒª e#

We will explain its purpose with a little example. Consider the following two Œª-terms:

\begin{code}
  _ = Œõ ‚àã ` "a"
  _ = Œõ ‚àã "x" ‚Ü¶ ` "a" ‚Äø ` "x"
\end{code}

These Œª-terms are obviously not the same, nor can either be Œ≤-reduced. But what if we apply both to the same argument \verb#` "b"#?

\begin{code}
  _ = Œõ ‚àã ` "a" ‚Äø ` "b"
  _ = ("x" ‚Ü¶ ` "a" ‚Äø ` "x") ‚Äø ` "b" ‚Üí‚ü® Œ≤ ‚ü© ` "a" ‚Äø ` "b" Œª-end
\end{code}

They compute to the same expression \verb#` "a" ‚Äø ` "b"#. In a sense, the first two expressions are the same, because they do the same. This is an instance of \textit{function extensionality}. The second Œª-term just wraps \verb#` "a"# in a function, but this unwrapping cannot be undone, or \enquote{reduced} in a sense. It may be desireable to be able to do this, and that is what Œ∑-reduction states.

\begin{code}
  _ = "x" ‚Ü¶ ` "a" ‚Äø ` "x" ‚Üí‚ü® Œ∑ ‚ü© ` "a" Œª-end
\end{code}

\section{Syntax}\label{syntax}

\subsection{Parser Combinators}

\subsection{Core Syntax}

\subsection{Extended Syntax}

\section{Combinatory Logic}

\section{Church Encodings}

\end{document}
